name: Build All AAP Image Flavors (AWS)

on:
  workflow_dispatch:
    inputs:
      aap_version:
        description: 'AAP Version to build'
        required: true
        type: choice
        options:
          - '2.5'
          - '2.6'
        default: '2.5'

env:
  PACKER_VERSION: "latest"
  PACKER_FILE: ./images/packer/aap.pkr.hcl
  INSTALLER_REGISTRY_USERNAME: ${{ secrets.INSTALLER_REGISTRY_USERNAME }}
  INSTALLER_REGISTRY_PASSWORD: ${{ secrets.INSTALLER_REGISTRY_PASSWORD }}
  INSTALLER_ADMIN_PW: ${{ secrets.INSTALLER_ADMIN_PW }}
  GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
  RHEL_USER_PASSWORD: ${{ secrets.RHEL_USER_PASSWORD }}

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        flavor: [CEH]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set INSTALLER_URL based on AAP version
        run: |
          if [ "${{ github.event.inputs.aap_version }}" == "2.6" ]; then
            INSTALLER_URL="${{ secrets.INSTALLER_URL_26 }}"
            echo "Using AAP 2.6 installer URL"
          else
            INSTALLER_URL="${{ secrets.INSTALLER_URL_25 }}"
            echo "Using AAP 2.5 installer URL"
          fi

          if [ -z "$INSTALLER_URL" ]; then
            echo "ERROR: INSTALLER_URL secret is empty or not set!"
            echo "Please configure INSTALLER_URL_25 or INSTALLER_URL_26 in GitHub secrets"
            exit 1
          fi

          echo "INSTALLER_URL length: ${#INSTALLER_URL} characters"
          echo "INSTALLER_URL=$INSTALLER_URL" >> $GITHUB_ENV

      - name: Debug workflow inputs and environment
        run: |
          echo "AAP Version Input: ${{ github.event.inputs.aap_version }}"
          if [ -z "$INSTALLER_URL" ]; then
            echo "ERROR: INSTALLER_URL is empty!"
            exit 1
          else
            echo "INSTALLER_URL is set (length: ${#INSTALLER_URL})"
          fi
          echo "Flavor: ${{ matrix.flavor }}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Set up Packer
        uses: hashicorp/setup-packer@main
        with:
          version: ${{ env.PACKER_VERSION }}

      - name: Run `packer init`
        id: init
        run: "packer init ${{ env.PACKER_FILE }}"

      - name: Run `packer validate`
        id: validate
        run: "packer validate ${{ env.PACKER_FILE }}"

      - name: Set build variables based on flavor
        run: |
          if [[ "${{ matrix.flavor }}" == "C" ]]; then
            export AAP_INCLUDE_CONTROLLER=true
            export AAP_INCLUDE_EDA_CONTROLLER=false
            export AAP_INCLUDE_AUTOMATION_HUB=false
          elif [[ "${{ matrix.flavor }}" == "CE" ]]; then
            export AAP_INCLUDE_CONTROLLER=true
            export AAP_INCLUDE_EDA_CONTROLLER=true
            export AAP_INCLUDE_AUTOMATION_HUB=false
          elif [[ "${{ matrix.flavor }}" == "CH" ]]; then
            export AAP_INCLUDE_CONTROLLER=true
            export AAP_INCLUDE_EDA_CONTROLLER=false
            export AAP_INCLUDE_AUTOMATION_HUB=true
          elif [[ "${{ matrix.flavor }}" == "CEH" ]]; then
            export AAP_INCLUDE_CONTROLLER=true
            export AAP_INCLUDE_EDA_CONTROLLER=true
            export AAP_INCLUDE_AUTOMATION_HUB=true
          fi

          echo "AAP_INCLUDE_CONTROLLER=${AAP_INCLUDE_CONTROLLER}" >> $GITHUB_ENV
          echo "AAP_INCLUDE_EDA_CONTROLLER=${AAP_INCLUDE_EDA_CONTROLLER}" >> $GITHUB_ENV
          echo "AAP_INCLUDE_AUTOMATION_HUB=${AAP_INCLUDE_AUTOMATION_HUB}" >> $GITHUB_ENV

      - name: Build AAP Image
        run: |
          echo "AWS_DEFAULT_REGION: $AWS_DEFAULT_REGION"
          echo "AWS_REGION: $AWS_REGION"
          echo "AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID:0:10}..."
          packer build \
            -var "aws_region=${{ secrets.AWS_REGION || 'us-east-1' }}" \
            -var "aap_include_controller=${AAP_INCLUDE_CONTROLLER}" \
            -var "aap_include_eda_controller=${AAP_INCLUDE_EDA_CONTROLLER}" \
            -var "aap_include_automation_hub=${AAP_INCLUDE_AUTOMATION_HUB}" \
            -force ${{ env.PACKER_FILE }}

      - name: Get AMI ID and rename with version
        id: get-ami
        run: |
          # Get the temporary AMI ID
          TEMP_AMI_ID=$(jq -r '.builds[0].artifact_id' manifest.json | cut -d: -f2)
          echo "Found temporary AMI ID: $TEMP_AMI_ID"
          
          # Extract version from the file downloaded from Packer build
          if [ -f /tmp/aap_version_*.txt ]; then
            AAP_VERSION=$(cat /tmp/aap_version_*.txt | tr -d "[]'\"" | sed 's/bundle-//' | sed 's/-x86_64//')
            echo "Extracted AAP Version from Packer build: $AAP_VERSION"
          elif [ -f /tmp/version.txt ]; then
            AAP_VERSION=$(grep installer_version /tmp/version.txt | cut -d= -f2 | tr -d "[]'\"" | sed 's/bundle-//' | sed 's/-x86_64//')
            echo "Extracted AAP Version from version.txt: $AAP_VERSION"
          else
            # Fallback: extract from installer URL if version files not available
            AAP_VERSION=$(echo "${{ env.INSTALLER_URL }}" | grep -oP 'setup-\K[0-9]+\.[0-9]+-[0-9]+' || echo "2.5-17")
            echo "Using version from URL fallback: $AAP_VERSION"
          fi
          
          # Create final AMI name with version (convert flavor to lowercase)
          FLAVOR_LOWER=$(echo "${{ matrix.flavor }}" | tr '[:upper:]' '[:lower:]')
          FINAL_NAME="aap-$AAP_VERSION-$FLAVOR_LOWER-$(date +%Y%m%d)"
          echo "Final AMI name: $FINAL_NAME"
          
          # Copy AMI with new name
          echo "Copying AMI $TEMP_AMI_ID to new name $FINAL_NAME"
          NEW_AMI_ID=$(aws ec2 copy-image \
            --source-image-id "$TEMP_AMI_ID" \
            --source-region ${{ secrets.AWS_REGION || 'us-east-1' }} \
            --name "$FINAL_NAME" \
            --description "AAP $AAP_VERSION ${{ matrix.flavor }} built on $(date +%Y-%m-%d)" \
            --region ${{ secrets.AWS_REGION || 'us-east-1' }} \
            --query 'ImageId' \
            --output text)
          
          echo "New AMI ID: $NEW_AMI_ID"
          
          # Wait for the new AMI to be available
          echo "Waiting for new AMI to be available..."
          aws ec2 wait image-available --image-ids "$NEW_AMI_ID" --region ${{ secrets.AWS_REGION || 'us-east-1' }}
          
          # Delete the temporary AMI
          echo "Deleting temporary AMI: $TEMP_AMI_ID"
          aws ec2 deregister-image --image-id "$TEMP_AMI_ID" --region ${{ secrets.AWS_REGION || 'us-east-1' }}
          
          # Output the final AMI ID for export
          echo "ami_id=$NEW_AMI_ID" >> $GITHUB_OUTPUT
          echo "final_name=$FINAL_NAME" >> $GITHUB_OUTPUT
          echo "Final AMI ready: $NEW_AMI_ID ($FINAL_NAME)"

      - name: Export AMI to S3 as qcow2
        id: export-ami
        env:
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}
        run: |
          # Set variables
          AMI_ID="${{ steps.get-ami.outputs.ami_id }}"
          S3_BUCKET="${{ secrets.S3_BUCKET_NAME || 'aap-qcow2-images' }}"
          FLAVOR_LOWER=$(echo "${{ matrix.flavor }}" | tr '[:upper:]' '[:lower:]')
          S3_PREFIX="aap-images/$FLAVOR_LOWER"
          EXPORT_TASK_NAME="aap-$FLAVOR_LOWER-$(date +%Y%m%d-%H%M%S)"
          
          echo "Exporting AMI $AMI_ID to S3 bucket: s3://$S3_BUCKET/$S3_PREFIX"
          
          # Create VM export task (using raw format as QCOW2 is not supported)
          EXPORT_TASK_ID=$(aws ec2 export-image \
            --image-id "$AMI_ID" \
            --disk-image-format raw \
            --s3-export-location S3Bucket="$S3_BUCKET",S3Prefix="$S3_PREFIX/" \
            --description "AAP $FLAVOR_LOWER raw export from $AMI_ID (for qcow2 conversion)" \
            --tag-specifications "ResourceType=export-image-task,Tags=[{Key=Name,Value=$EXPORT_TASK_NAME},{Key=Flavor,Value=$FLAVOR_LOWER},{Key=BuildDate,Value=$(date +%Y-%m-%d)}]" \
            --query 'ExportImageTaskId' \
            --output text)
          
          echo "export_task_id=$EXPORT_TASK_ID" >> $GITHUB_OUTPUT
          echo "Started export task: $EXPORT_TASK_ID"

      - name: Wait for export completion
        id: wait-export
        run: |
          EXPORT_TASK_ID="${{ steps.export-ami.outputs.export_task_id }}"
          echo "Monitoring export task: $EXPORT_TASK_ID"
          
          # Wait for export to complete (timeout after 2 hours)
          TIMEOUT=7200
          ELAPSED=0
          INTERVAL=60
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            STATUS=$(aws ec2 describe-export-image-tasks \
              --export-image-task-ids "$EXPORT_TASK_ID" \
              --query 'ExportImageTasks[0].Status' \
              --output text)

            PROGRESS=$(aws ec2 describe-export-image-tasks \
              --export-image-task-ids "$EXPORT_TASK_ID" \
              --query 'ExportImageTasks[0].Progress' \
              --output text)

            STATUS_MESSAGE=$(aws ec2 describe-export-image-tasks \
              --export-image-task-ids "$EXPORT_TASK_ID" \
              --query 'ExportImageTasks[0].StatusMessage' \
              --output text)

            echo "Export status: $STATUS, Progress: $PROGRESS%"
            if [ -n "$STATUS_MESSAGE" ] && [ "$STATUS_MESSAGE" != "None" ]; then
              echo "Status message: $STATUS_MESSAGE"
            fi
            
            if [ "$STATUS" = "completed" ]; then
              S3_BUCKET=$(aws ec2 describe-export-image-tasks \
                --export-image-task-ids "$EXPORT_TASK_ID" \
                --query 'ExportImageTasks[0].S3ExportLocation.S3Bucket' \
                --output text)
              S3_PREFIX=$(aws ec2 describe-export-image-tasks \
                --export-image-task-ids "$EXPORT_TASK_ID" \
                --query 'ExportImageTasks[0].S3ExportLocation.S3Prefix' \
                --output text)
              S3_KEY=$(aws ec2 describe-export-image-tasks \
                --export-image-task-ids "$EXPORT_TASK_ID" \
                --query 'ExportImageTasks[0].S3ExportLocation.S3Key' \
                --output text)

              # Fallback: If S3_KEY is None or empty, construct it from S3_PREFIX and EXPORT_TASK_ID
              if [ -z "$S3_KEY" ] || [ "$S3_KEY" = "None" ]; then
                echo "S3Key not returned by API, constructing from prefix and task ID..."
                S3_KEY="${S3_PREFIX}${EXPORT_TASK_ID}.raw"
              fi

              echo "âœ… Raw image export completed!"
              echo "ðŸ“¦ Raw image available at: s3://$S3_BUCKET/$S3_KEY"
              
              # Convert RAW to qcow2 using temporary EC2 instance
              echo "Converting raw image to qcow2 format using temporary EC2 instance..."

              RAW_FILE=$(basename "$S3_KEY")
              AMI_NAME="${{ steps.get-ami.outputs.final_name }}"
              QCOW2_FILE="${AMI_NAME}.qcow2"
              FLAVOR_LOWER=$(echo "${{ matrix.flavor }}" | tr '[:upper:]' '[:lower:]')
              QCOW2_S3_KEY="aap-images/$FLAVOR_LOWER/${QCOW2_FILE}"

              echo "Will create qcow2: $QCOW2_FILE"

              # Create temporary SSH key
              ssh-keygen -t rsa -b 2048 -f /tmp/converter-key -N ""
              chmod 600 /tmp/converter-key

              # Create temporary security group allowing SSH
              TEMP_SG_ID=$(aws ec2 create-security-group \
                --group-name "qcow2-converter-$(date +%s)" \
                --description "Temporary SG for qcow2 conversion" \
                --query 'GroupId' \
                --output text)

              echo "Created security group: $TEMP_SG_ID"

              # Add SSH ingress rule
              aws ec2 authorize-security-group-ingress \
                --group-id $TEMP_SG_ID \
                --protocol tcp \
                --port 22 \
                --cidr 0.0.0.0/0

              # Import SSH key
              KEY_NAME="converter-$(date +%s)"
              aws ec2 import-key-pair \
                --key-name $KEY_NAME \
                --public-key-material fileb:///tmp/converter-key.pub

              # Get latest RHEL 9 AMI
              CONVERTER_AMI=$(aws ec2 describe-images \
                --owners 309956199498 \
                --filters "Name=name,Values=RHEL-9*_HVM-*-x86_64-*-GP*" \
                          "Name=state,Values=available" \
                --query 'Images | sort_by(@, &CreationDate) | [-1].ImageId' \
                --output text)

              echo "Using AMI: $CONVERTER_AMI"

              # Create user-data script
              cat > /tmp/user-data.sh << 'USERDATA'
              #!/bin/bash
              set -x
              exec > /var/log/user-data.log 2>&1
              yum install -y qemu-img awscli
              USERDATA

              # Launch instance with 100GB root volume
              CONVERTER_INSTANCE=$(aws ec2 run-instances \
                --image-id $CONVERTER_AMI \
                --instance-type t3.medium \
                --key-name $KEY_NAME \
                --security-group-ids $TEMP_SG_ID \
                --block-device-mappings '[{"DeviceName":"/dev/sda1","Ebs":{"VolumeSize":100,"VolumeType":"gp3","DeleteOnTermination":true}}]' \
                --user-data file:///tmp/user-data.sh \
                --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=qcow2-converter},{Key=Purpose,Value=temporary}]" \
                --query 'Instances[0].InstanceId' \
                --output text)

              echo "Launched converter instance: $CONVERTER_INSTANCE"

              # Wait for instance to be running
              echo "Waiting for instance to be running..."
              aws ec2 wait instance-running --instance-ids $CONVERTER_INSTANCE

              # Get public IP
              PUBLIC_IP=$(aws ec2 describe-instances \
                --instance-ids $CONVERTER_INSTANCE \
                --query 'Reservations[0].Instances[0].PublicIpAddress' \
                --output text)
              echo "Instance IP: $PUBLIC_IP"

              # Wait for SSH to be ready
              echo "Waiting for SSH to be ready..."
              for i in {1..30}; do
                if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 -i /tmp/converter-key ec2-user@$PUBLIC_IP "echo SSH ready" 2>/dev/null; then
                  echo "SSH is ready"
                  break
                fi
                if [ $i -eq 30 ]; then
                  echo "ERROR: SSH did not become ready in time"
                  aws ec2 terminate-instances --instance-ids $CONVERTER_INSTANCE
                  aws ec2 delete-key-pair --key-name $KEY_NAME
                  sleep 30
                  aws ec2 delete-security-group --group-id $TEMP_SG_ID || true
                  exit 1
                fi
                sleep 10
              done

              # Wait for tools to be installed
              echo "Waiting for qemu-img and aws-cli installation..."
              for i in {1..30}; do
                if ssh -o StrictHostKeyChecking=no -i /tmp/converter-key ec2-user@$PUBLIC_IP "command -v qemu-img && command -v aws" 2>/dev/null; then
                  echo "Tools are installed"
                  break
                fi
                if [ $i -eq 30 ]; then
                  echo "ERROR: Tools did not install in time"
                  aws ec2 terminate-instances --instance-ids $CONVERTER_INSTANCE
                  aws ec2 delete-key-pair --key-name $KEY_NAME
                  sleep 30
                  aws ec2 delete-security-group --group-id $TEMP_SG_ID || true
                  exit 1
                fi
                sleep 10
              done

              # Run conversion directly via SSH (using inline command to avoid heredoc issues)
              echo "Running qcow2 conversion (this may take 10-15 minutes)..."
              ssh -o StrictHostKeyChecking=no -i /tmp/converter-key ec2-user@$PUBLIC_IP "export AWS_ACCESS_KEY_ID='$AWS_ACCESS_KEY_ID' && export AWS_SECRET_ACCESS_KEY='$AWS_SECRET_ACCESS_KEY' && export AWS_DEFAULT_REGION='$AWS_DEFAULT_REGION' && echo 'Downloading raw image...' && aws s3 cp s3://$S3_BUCKET/$S3_KEY /tmp/$RAW_FILE --no-progress && echo 'Converting to qcow2...' && sudo qemu-img convert -f raw -O qcow2 -c /tmp/$RAW_FILE /tmp/$QCOW2_FILE && echo 'Removing raw file...' && rm -f /tmp/$RAW_FILE && echo 'Uploading qcow2...' && aws s3 cp /tmp/$QCOW2_FILE s3://$S3_BUCKET/$QCOW2_S3_KEY --no-progress && echo 'Cleanup complete' && sudo rm -f /tmp/$QCOW2_FILE"

              # Cleanup: Terminate instance
              echo "Terminating converter instance..."
              aws ec2 terminate-instances --instance-ids $CONVERTER_INSTANCE

              # Wait for termination
              aws ec2 wait instance-terminated --instance-ids $CONVERTER_INSTANCE

              # Delete SSH key
              aws ec2 delete-key-pair --key-name $KEY_NAME
              rm -f /tmp/converter-key /tmp/converter-key.pub /tmp/user-data.sh

              # Delete security group
              echo "Deleting security group..."
              sleep 30
              aws ec2 delete-security-group --group-id $TEMP_SG_ID || echo "Security group cleanup will happen automatically"

              # Delete the raw file from S3 (keep only qcow2)
              echo "Deleting raw file from S3..."
              aws s3 rm "s3://$S3_BUCKET/$S3_KEY"

              echo "âœ… Conversion completed!"
              echo "ðŸ“¦ qcow2 image available at: s3://$S3_BUCKET/$QCOW2_S3_KEY"
              echo "s3_url=s3://$S3_BUCKET/$QCOW2_S3_KEY" >> $GITHUB_OUTPUT
              break
            elif [ "$STATUS" = "cancelled" ] || [ "$STATUS" = "cancelling" ]; then
              echo "âŒ Export was cancelled"
              exit 1
            elif [ "$STATUS" = "failed" ]; then
              echo "âŒ Export failed"
              aws ec2 describe-export-image-tasks --export-image-task-ids "$EXPORT_TASK_ID"
              exit 1
            fi
            
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "âŒ Export timed out after 2 hours"
            exit 1
          fi

      - name: Rename qcow2 file with version
        id: rename-qcow2
        if: success()
        run: |
          # Get the original S3 location and AMI name with version
          ORIGINAL_S3_URL="${{ steps.wait-export.outputs.s3_url }}"
          AMI_NAME="${{ steps.get-ami.outputs.final_name }}"
          S3_BUCKET="${{ secrets.S3_BUCKET_NAME || 'aap-qcow2-images' }}"
          FLAVOR_LOWER=$(echo "${{ matrix.flavor }}" | tr '[:upper:]' '[:lower:]')

          # Extract the original S3 key from the URL
          ORIGINAL_S3_KEY=$(echo "$ORIGINAL_S3_URL" | sed "s|s3://$S3_BUCKET/||")

          # Create new S3 key with versioned name
          NEW_S3_KEY="aap-images/$FLAVOR_LOWER/${AMI_NAME}.qcow2"

          echo "Renaming qcow2 file in S3..."
          echo "  From: $ORIGINAL_S3_KEY"
          echo "  To: $NEW_S3_KEY"

          # Copy to new name
          aws s3 cp "s3://$S3_BUCKET/$ORIGINAL_S3_KEY" "s3://$S3_BUCKET/$NEW_S3_KEY"

          # Delete the old file
          aws s3 rm "s3://$S3_BUCKET/$ORIGINAL_S3_KEY"

          echo "Renamed to: s3://$S3_BUCKET/$NEW_S3_KEY"
          echo "versioned_s3_url=s3://$S3_BUCKET/$NEW_S3_KEY" >> $GITHUB_OUTPUT

      - name: Cleanup AWS resources
        if: always()
        run: |
          AMI_ID="${{ steps.get-ami.outputs.ami_id }}"

          if [ -n "$AMI_ID" ] && [ "$AMI_ID" != "null" ]; then
            echo "ðŸ§¹ Cleaning up AWS resources for AMI: $AMI_ID"
            
            # Get snapshot IDs associated with the AMI
            SNAPSHOT_IDS=$(aws ec2 describe-images \
              --image-ids "$AMI_ID" \
              --query 'Images[0].BlockDeviceMappings[*].Ebs.SnapshotId' \
              --output text \
              --region ${{ secrets.AWS_REGION || 'us-east-1' }} || echo "")
            
            # Deregister the AMI
            echo "ðŸ—‘ï¸ Deregistering AMI: $AMI_ID"
            aws ec2 deregister-image \
              --image-id "$AMI_ID" \
              --region ${{ secrets.AWS_REGION || 'us-east-1' }} || echo "Failed to deregister AMI"
            
            # Delete associated snapshots
            if [ -n "$SNAPSHOT_IDS" ] && [ "$SNAPSHOT_IDS" != "None" ]; then
              for SNAPSHOT_ID in $SNAPSHOT_IDS; do
                if [ "$SNAPSHOT_ID" != "None" ]; then
                  echo "ðŸ—‘ï¸ Deleting snapshot: $SNAPSHOT_ID"
                  aws ec2 delete-snapshot \
                    --snapshot-id "$SNAPSHOT_ID" \
                    --region ${{ secrets.AWS_REGION || 'us-east-1' }} || echo "Failed to delete snapshot $SNAPSHOT_ID"
                fi
              done
            fi
            
            echo "âœ… AWS cleanup completed"
          else
            echo "â„¹ï¸ No AMI to cleanup"
          fi

      - name: Generate build summary
        if: success()
        run: |
          echo "## ðŸŽ‰ AAP Image Build Complete - Flavor: ${{ matrix.flavor }}" >> $GITHUB_STEP_SUMMARY
          echo "**AMI Name:** ${{ steps.get-ami.outputs.final_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**S3 Location:** ${{ steps.rename-qcow2.outputs.versioned_s3_url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Build Date:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**Components:**" >> $GITHUB_STEP_SUMMARY
          echo "- Controller: ${AAP_INCLUDE_CONTROLLER}" >> $GITHUB_STEP_SUMMARY
          echo "- EDA: ${AAP_INCLUDE_EDA_CONTROLLER}" >> $GITHUB_STEP_SUMMARY
          echo "- Hub: ${AAP_INCLUDE_AUTOMATION_HUB}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Note:** AMI and snapshots have been automatically cleaned up to save costs." >> $GITHUB_STEP_SUMMARY

      # - name: Capture installer details from Packer
      #   if: success()
      #   run: |
      #     if [[ -f /tmp/version.txt ]]; then
      #       while IFS='=' read -r key value; do
      #         echo "$key=$value" >> $GITHUB_ENV
      #       done < /tmp/version.txt
      #     fi

      # - name: Generate workflow summary
      #   run: |
      #     echo "### AAP Image Build Summary" >> $GITHUB_STEP_SUMMARY
      #     echo "**Installer Filename:** ${{ env.installer_filename }}" >> $GITHUB_STEP_SUMMARY
      #     echo "**Installer SHA-256 Checksum:** ${{ env.installer_checksum }}" >> $GITHUB_STEP_SUMMARY
